// Generated by LiveScript 1.5.0
(function(){
  var ref$, parseFilters, getArgs, getRaw, getOrigResults, replacer, getReplacementFunc, replace, slice$ = [].slice;
  ref$ = require('./utils'), parseFilters = ref$.parseFilters, getArgs = ref$.getArgs, getRaw = ref$.getRaw, getOrigResults = ref$.getOrigResults;
  replacer = function(input, node, queryEngine){
    return function(arg$, replacementArg, filterArg){
      var ref$, selector, filters, queryResults, query, origResults, results, raw, join, textOperations, filterName, args, res$, i$, len$, result, output;
      filterArg = filterArg || replacementArg;
      ref$ = parseFilters(filterArg), selector = ref$[0], filters = ref$[1];
      queryResults = getOrigResults(node, selector, filterArg);
      query = queryResults(queryEngine, node);
      origResults = query(replacementArg);
      if (origResults.length) {
        results = origResults;
        raw = {
          prepend: '',
          append: ''
        };
        join = null;
        textOperations = [];
        while (filters.length) {
          filterName = filters.shift();
          args = getArgs(filters);
          filter(filterName, args, {
            raw: raw,
            results: results,
            textOperations: textOperations
          });
        }
        res$ = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          result = results[i$];
          res$.push(getRaw(input, result));
        }
        raw.results = res$;
        output = raw + ".prepend" + (join != null
          ? rawResults.join(join)
          : raw.results[0]) + raw + ".append";
        if (textOperations.length) {
          return fold(curry$(function(x$, y$){
            return y$(x$);
          }), output, textOperations);
        } else {
          return output;
        }
      } else {
        return '';
      }
    };
  };
  getReplacementFunc = require('./replacement').getReplacementFunc;
  replace = function(replacement, input, nodes, queryEngine){
    var inputLines, colOffset, lineOffset, lastLine, prevNode, replaceNode, i$, len$, node, ref$, start, end, startLineNum, endLineNum, numberOfLines, startCol, endCol, replaceLines, startLine, endLine, startContext, endContext, replaceLast, endLen;
    inputLines = lines(input);
    colOffset = 0;
    lineOffset = 0;
    lastLine = null;
    prevNode = {
      end: 0
    };
    replaceNode = getReplacementFunc(replacement, input, queryEngine);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      node = nodes[i$];
      if (node.start < prevNode.end) {
        continue;
      }
      ref$ = node.loc, start = ref$.start, end = ref$.end;
      startLineNum = start.line - 1 + lineOffset;
      endLineNum = end.line - 1 + lineOffset;
      numberOfLines = endLineNum - startLineNum + 1;
      colOffset = lastLine === startLineNum ? colOffset : 0;
      startCol = start.column + colOffset;
      endCol = end.column + (startLineNum === endLineNum ? colOffset : 0);
      replaceLines = lines(replaceNode(node));
      startLine = inputLines[startLineNum];
      endLine = inputLines[endLineNum];
      startContext = startLine.slice(0, startCol);
      endContext = endLine.slice(endCol);
      replaceLines[0] = startContext + "" + ((ref$ = replaceLines[0]) != null ? ref$ : '');
      replaceLast = replaceLines[replaceLines.length - 1];
      endLen = replaceLast.length;
      replaceLines[replaceLines.length - 1] = replaceLast + "" + endContext;
      inputLines.splice.apply(inputLines, [startLineNum, numberOfLines].concat(slice$.call(replaceLines)));
      lineOffset += replaceLines.length - numberOfLines;
      colOffset += endLen - endCol;
      lastLine = endLineNum + lineOffset;
      prevNode = node;
    }
    return unlines(inputLines);
  };
  module.exports = {
    replace: replace
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
