// Generated by LiveScript 1.5.0
(function(){
  var version, ref$, searchTarget, getQueryEngine, getDisplayFilename, Logger, search, Runner, slice$ = [].slice;
  version = require('../package.json').version;
  ref$ = require('./utils'), searchTarget = ref$.searchTarget, getQueryEngine = ref$.getQueryEngine, getDisplayFilename = ref$.getDisplayFilename;
  Logger = require('../logger');
  search = require('../search');
  Runner = (function(){
    Runner.displayName = 'Runner';
    var prototype = Runner.prototype, constructor = Runner;
    importAll$(prototype, arguments[0]);
    function Runner(arg$){
      var ref$, ref1$;
      ref$ = arg$ != null
        ? arg$
        : {}, this.opts = ref$.opts, this.args = ref$.args, this.error = (ref1$ = ref$.error) != null
        ? ref1$
        : function(it){
          throw new Error(it);
        }, this.callback = (ref1$ = ref$.callback) != null
        ? ref1$
        : function(){}, this.exit = (ref1$ = ref$.exit) != null
        ? ref1$
        : function(){}, this.data = (ref1$ = ref$.data) != null ? ref1$ : false, this.stdin = ref$.stdin, this.fs = (ref1$ = ref$.fs) != null
        ? ref1$
        : require('fs'), this.textFormat = (ref1$ = ref$.textFormat) != null
        ? ref1$
        : require('cli-color'), this.input = ref$.input, this.console = (ref1$ = ref$.console) != null ? ref1$ : _console;
      this.validateArgs();
      this.parseArgs();
      this.extractOpts();
      this.startDebug();
      this.handleVersion();
      this.handleHelp();
      this.handleJsx();
      this.queryEngine = getQueryEngine(this.options);
      this.setParser();
      this.setContext();
      this.handleFile();
      this.handleRecursive();
      this.handleReplace();
      this.handleSelector();
      this.options.displayFilename = getDisplayFilename(this.options, this.targets);
      this.setOutputFormat();
      this.prepareSearch();
      this.parseSelector();
      this.endDebug();
    }
    run(function(){
      this.setTestExt();
      this.setTestExclude();
      return this.doSearch();
    });
    searchInput(function(){
      if (!this.input) {
        return;
      }
      this.search('(input)', this.input);
      this.resultsFormat = this.search.resultsFormat;
      return this.end(['-']);
    });
    searchTargets(function(){
      var cwd;
      cwd = process.cwd();
      async.eachSeries(this.targets, searchTarget(cwd, cwd), function(){
        return end(this.targetPaths);
      });
    });
    doSearch(function(){
      this.targetPaths = [];
      return this.searchInput() || this.searchTargets();
    });
    prepareSearch(function(){
      return this.search = new Search({
        console: this.console,
        parsed: this.parsed,
        parserOptions: this.parserOptions,
        callback: this.callback,
        callCallback: this.callCallback,
        options: this.options,
        opts: this.opts
      });
    });
    parseSelector(function(){
      this.parsed == null && (this.parsed = {});
      this.time('parse-selector');
      return this.parsed.selector = this.queryEngine.parse(this.selector);
    });
    setTestExt(function(){
      var this$ = this;
      return this.testExt = exts.length === 0 || exts.length === 1 && exts[0] === '.'
        ? function(){
          return true;
        }
        : function(it){
          return it.match(RegExp('\\.(?:' + exts.join('|') + ')$'));
        };
    });
    excludeFun(function(){
      var this$ = this;
      return function(file, basePath, upPath){
        var filePath;
        filePath = path.relative(basePath, path.join(upPath, file));
        return this$.exclude.every(function(excludePattern){
          return !minimatch(filePath, excludePattern, this.options.minimatchOptions);
        });
      };
    });
    setTestExclude(function(){
      return this.testExclude = !this.exclude || this.exclude.length === 0
        ? function(){
          return true;
        }
        : this.excludeFun();
    });
    setOutputFormat(function(){
      var ref$;
      this.color = Obj.map(function(it){
        if (this.options.color) {
          return it;
        } else {
          return function(it){
            return it + "";
          };
        }
      }, {
        green: (ref$ = this.textFormat).green,
        cyan: ref$.cyan,
        magenta: ref$.magenta,
        red: ref$.red
      });
      this.bold = this.options.bold
        ? this.textFormat.bold
        : function(it){
          return it + "";
        };
      return this.textFormatFuncs = {
        color: color,
        bold: bold
      };
    });
    setParser(function(){
      var ref$, parser, parserOptions;
      ref$ = (function(){
        switch (options.parser[0]) {
        case 'acorn':
          return [acorn, options.parser[1]];
        default:
          return [require(options.parser[0]), options.parser[1]];
        }
      }()), parser = ref$[0], parserOptions = ref$[1];
      this.parser = parser;
      return this.parserOptions = parserOptions;
    });
    setContext(function(){
      var ref$, ref1$;
      (ref$ = this.options).context == null && (ref$.context = (ref$ = this.options.NUM) != null ? ref$ : 0);
      (ref$ = this.options).beforeContext == null && (ref$.beforeContext = this.options.context);
      return (ref1$ = (ref$ = this.options).afterContext) != null
        ? ref1$
        : ref$.afterContext = this.options.context;
    });
    handleRecursive(function(){
      if (!this.targets.length) {
        return this.targets = options.recursive
          ? ['.']
          : ['-'];
      }
    });
    handleSelector(function(){
      var helpString;
      if (this.selector == null) {
        error('Error: No selector specified.');
        helpString = getHelp();
        callback(helpString);
        exit(2, helpString);
      }
    });
    handleReplaceFile(function(){
      var e;
      if (!this.options.replaceFile) {
        return;
      }
      try {
        return this.replacement = this.fs.readFileSync(that, 'utf8').replace(/([\s\S]*)\n$/, '$1');
      } catch (e$) {
        e = e$;
        this.error("Error: No such file '" + this.options.replaceFile + "'.");
        this.exit(2);
      }
    });
    isReplace(function(){
      return this.options.replace != null || this.options.replaceFunc;
    });
    handleReplace(function(){
      var that;
      if ((that = isReplace) != null) {
        return this.replacement = that;
      } else {
        return this.handleReplaceFile();
      }
    });
    selectorFromFile(function(){
      var e;
      try {
        this.selector = this.fs.readFileSync(that, 'utf8');
      } catch (e$) {
        e = e$;
        this.error("Error: No such file '" + this.options.file + "'.");
        this.exit(2);
        return;
      }
      return this.targets = this.positional;
    });
    selectorFromPos(function(){
      this.selector = this.positional[0];
      return this.targets = slice$.call(this.positional, 1);
    });
    handleFile(function(){
      if (this.options.file != null) {
        return this.selectorFromFile();
      } else {
        return this.selectorFromPos();
      }
    });
    handleHelp(function(){
      var helpString;
      if (!this.options.help) {
        return;
      }
      helpString = this.getHelp();
      this.callback(helpString);
      this.exit(0, helpString);
    });
    getHelp(function(){
      return help(generateHelp, generateHelpForOption, this.positional, {
        version: version
      });
    });
    extractOpts(function(){
      this.exts = this.options.extensions;
      this.exclude = this.options.exclude;
      return this.callCallback = !this.options.quiet && !this.options.json && !this.options.to && !this.options.inPlace;
    });
    parseArgs(function(){
      var options, positional, debug, e;
      try {
        options = parseOptions(this.args), positional = options._, debug = options.debug;
        this.options = options;
        this.positional = positional || [];
        return this.debug = debug;
      } catch (e$) {
        e = e$;
        this.error(e.message);
        this.exit(2);
      }
    });
    validateArgs(function(){
      if (this.args == null) {
        this.error('Error: Must specify arguments.');
        this.exit(2);
      }
    });
    handleJsx(function(){
      if (!this.options.jsx) {
        return;
      }
      this.options.extensions.push('jsx');
      if (this.options.parser[0] === 'acorn') {
        require('acorn-jsx');
        return this.options.parser[1].plugins = {
          jsx: true
        };
      }
    });
    handleVersion(function(){
      var versionString;
      if (!this.options.version) {
        return;
      }
      versionString = "grasp v" + version;
      this.callback(versionString);
      this.exit(0, versionString);
    });
    startDebug(function(){
      this.time('everything');
      this.log('options:');
      return this.log(options);
    });
    endDebug(function(){
      this.timeEnd('parse-selector');
      this.log('parsed-selector:');
      return this.log(JSON.stringify(this.parsed.selector, null, 2));
    });
    return Runner;
  }(Logger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
