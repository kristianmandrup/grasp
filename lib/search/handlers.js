// Generated by LiveScript 1.5.0
(function(){
  module.exports = [
    handleCount(function(){
      if (!this.options.count) {
        return;
      }
      return this.handleDisplayFilename() || this.countData();
    }), handleReplacement(function(){
      var replaced, e;
      if (this.replacement == null) {
        return;
      }
      try {
        replaced = replace(this.replacement, this.cleanInput, this.searchResults.sliced, this.queryEngine);
        if (this.replacePairs != null) {
          constructor.searchResults.format = 'pairs';
          return this.out([name, replaced]);
        } else {
          return this.out(replaced);
        }
      } catch (e$) {
        e = e$;
        return this.error(name + ": Error during replacement. " + e.message + ".");
      }
    }), handleDisplayFilename(function(){
      if (!this.options.displayFilename) {
        return;
      }
      if (this.options.json || this.data) {
        constructor.searchResults.format = 'pairs';
        return this.out([this.name, this.count]);
      } else {
        return this.out(formatCount(this.color, this.count, this.name));
      }
    }), handleFileMatching(function(){
      if (!(this.options.filesWithoutMatch || this.options.filesWithMatches)) {
        return;
      }
      if (this.isMatching != null) {
        return this.out(this.options.json || this.data
          ? this.name
          : formatName(this.color, this.name));
      }
    }), handlePairs(function(){
      if (!this.options.displayFilename) {
        return;
      }
      this.searchResults.format = 'pairs';
      return this.out([this.name, this.searchResults.sliced]);
    }), handleLists(function(){
      this.searchResults.format = 'lists';
      return this.out(this.searchResults.sliced);
    }), handleJsonData(function(){
      if (!(this.options.json || this.data)) {
        return;
      }
      return this.handlePairs() || this.handleLists();
    }), handleInputData(function(){
      var i$, ref$, len$, result, results$ = [];
      this.inputLines = lines(this.cleanInput);
      for (i$ = 0, len$ = (ref$ = this.searchResults.sliced).length; i$ < len$; ++i$) {
        result = ref$[i$];
        results$.push(this.out(formatResult(this.name, this.inputLines, this.inputLines.length, textFormatFuncs, this.options, this.result)));
      }
      return results$;
    }), handleData(function(){
      return this.handleJsonData() || this.handleInputData();
    })
  ];
}).call(this);
