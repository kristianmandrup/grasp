// Generated by LiveScript 1.5.0
(function(){
  var ref$, lines, unlines, filter, fold, capitalize, camelize, dasherize, doEach, append, prepend, wrap;
  ref$ = require('prelude-ls'), lines = ref$.lines, unlines = ref$.unlines, filter = ref$.filter, fold = ref$.fold, capitalize = ref$.capitalize, camelize = ref$.camelize, dasherize = ref$.dasherize;
  doEach = function(args, result){
    var i$, ref$, len$, ref1$, pre, post, results$ = [], results1$ = [], results2$ = [];
    switch (args[0]) {
    case 'before':
      for (i$ = 0, len$ = (ref$ = results).length; i$ < len$; ++i$) {
        result = ref$[i$];
        results$.push(result.raw.prepend = args[1] + "" + ((ref1$ = result.raw.prepend) != null ? ref1$ : ''));
      }
      return results$;
      break;
    case 'after':
      for (i$ = 0, len$ = (ref$ = results).length; i$ < len$; ++i$) {
        result = ref$[i$];
        results1$.push(result.raw.append = ((ref1$ = result.raw.append) != null ? ref1$ : '') + "" + args[1]);
      }
      return results1$;
      break;
    case 'wrap':
      ref$ = args.length === 2
        ? [args[1], args[1]]
        : [args[1], args[2]], pre = ref$[0], post = ref$[1];
      for (i$ = 0, len$ = (ref$ = results).length; i$ < len$; ++i$) {
        result = ref$[i$];
        result.raw.prepend = pre + "" + ((ref1$ = result.raw.prepend) != null ? ref1$ : '');
        results2$.push(result.raw.append = ((ref1$ = result.raw.append) != null ? ref1$ : '') + "" + post);
      }
      return results2$;
      break;
    default:
      throw new Error("'" + args[0] + "' is not supported by 'each'");
    }
  };
  append = function(results, arg){
    return results.push({
      type: 'Raw',
      raw: arg + ""
    });
  };
  prepend = function(results, arg){
    return results.unshift({
      type: 'Raw',
      raw: arg + ""
    });
  };
  wrap = function(raw, args){
    var ref$, pre, post;
    ref$ = args.length === 1 ? [args[0], args[0]] : args, pre = ref$[0], post = ref$[1];
    raw.prepend = pre + "" + raw + ".prepend";
    return raw.append += post + "";
  };
  filter = function(name, args, arg$){
    var raw, results, textOperations, join, i$, len$, arg, n, len, this$ = this;
    raw = arg$.raw, results = arg$.results, textOperations = arg$.textOperations;
    if (!args.length && (name === 'prepend' || name === 'before' || name === 'after' || name === 'prepend' || name === 'append' || name === 'wrap' || name === 'nth' || name === 'nth-last' || name === 'slice' || name === 'each' || name === 'replace' || name === 'substring' || name === 'substr' || name === 'str-slice')) {
      throw new Error("No arguments supplied for '" + filterName + "' filter");
    } else if (in$(name, ['replace']) && args.length < 2) {
      throw new Error("Must supply at least two arguments for '" + filterName + "' filter");
    }
    join = null;
    switch (name) {
    case 'join':
      join = args.length ? args[0] + "" : '';
      break;
    case 'before':
      raw.prepend = args[0] + "" + raw + ".prepend";
      break;
    case 'after':
      raw.append += args[0] + "";
      break;
    case 'wrap':
      wrap(raw, args);
      break;
    case 'prepend':
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        arg = args[i$];
        prepend(results(arg));
      }
      break;
    case 'append':
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        arg = args[i$];
        append(results(arg));
      }
      break;
    case 'each':
      if (args.length < 2) {
        throw new Error("No arguments supplied for 'each " + args[0] + "'");
      }
      doEach(args, result);
      break;
    case 'nth':
      n = +args[0];
      results = results.slice(n, n + 1);
      break;
    case 'nth-last':
      n = results.length - +args[0] - 1;
      results = results.slice(n, n + 1);
      break;
    case 'first':
    case 'head':
      results = results.slice(0, 1);
      break;
    case 'tail':
      results = results.slice(1);
      break;
    case 'last':
      len = results.length;
      results = results.slice(len - 1, len);
      break;
    case 'initial':
      results = results.slice(0, results.length - 1);
      break;
    case 'slice':
      results = [].slice.apply(results, args);
      break;
    case 'reverse':
      results.reverse();
      break;
    case 'replace':
      (function(args){
        var this$ = this;
        textOperations.push(function(it){
          return it.replace(args[0], args[1]);
        });
      }.call(this, args));
      break;
    case 'lowercase':
      textOperations.push(function(it){
        return it.toLowerCase();
      });
      break;
    case 'uppercase':
      textOperations.push(function(it){
        return it.toUpperCase();
      });
      break;
    case 'capitalize':
      textOperations.push(capitalize);
      break;
    case 'uncapitalize':
      textOperations.push(function(it){
        return it.charAt(0).toLowerCase() + it.slice(1);
      });
      break;
    case 'camelize':
      textOperations.push(camelize);
      break;
    case 'dasherize':
      textOperations.push(dasherize);
      break;
    case 'trim':
      textOperations.push(function(it){
        return it.trim();
      });
      break;
    case 'substring':
      (function(args){
        var this$ = this;
        textOperations.push(function(it){
          return it.substring(args[0], args[1]);
        });
      }.call(this, args));
      break;
    case 'substr':
      (function(args){
        var this$ = this;
        textOperations.push(function(it){
          return it.substr(args[0], args[1]);
        });
      }.call(this, args));
      break;
    case 'str-slice':
      (function(args){
        var this$ = this;
        textOperations.push(function(it){
          return it.slice(args[0], args[1]);
        });
      }.call(this, args));
      break;
    default:
      throw new Error("Invalid filter: " + filterName + (argsStr ? " " + argsStr : ''));
    }
    return [join, raw, results, textOperations];
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
