// Generated by LiveScript 1.5.0
(function(){
  var Search, slice$ = [].slice;
  module.exports = Search = (function(){
    Search.displayName = 'Search';
    var out, search, prototype = Search.prototype, constructor = Search;
    function Search(arg$){
      var out, console, callCallback, options;
      out = arg$.out, console = arg$.console, callCallback = arg$.callCallback, options = arg$.options;
      this.out = out;
      this.console = console;
      this.options = options;
      this.callCallback = callCallback;
      this.resultsData = [];
      this.resultsFormat = 'default';
    }
    out = function(it){
      this.resultsData.push(it);
      if (this.callCallback) {
        callback(it);
      }
    };
    search = function(name, input){
      var cleanInput, parsedInput, e, results, resultsLen, count, that, sortedResults, slicedResults, replaced, inputLines, inputLinesLength, i$, len$, result;
      if (debug) {
        this.console.time("search-total:" + name);
      }
      cleanInput = input.replace(/^#!.*\n/, '');
      try {
        if (debug) {
          this.console.time("parse-input:" + name);
        }
        parsedInput = parser.parse(cleanInput, parserOptions);
        if (debug) {
          this.console.timeEnd("parse-input:" + name);
        }
        if (options.printAst) {
          this.console.log(JSON.stringify(parsedInput, null, 2));
        }
      } catch (e$) {
        e = e$;
        throw new Error("Error: Could not parse JavaScript from '" + name + "'. " + e.message);
      }
      if (debug) {
        this.console.time("query:" + name);
      }
      results = queryEngine.queryParsed(parsedSelector, parsedInput);
      if (debug) {
        this.console.timeEnd("query:" + name);
      }
      resultsLen = results.length;
      count = (that = options.maxCount) != null ? min(that, resultsLen) : resultsLen;
      sortedResults = sortWith(resultsSortFunc, results);
      slicedResults = slice$.call(sortedResults, 0, count);
      if (typeof replacement != 'undefined' && replacement !== null) {
        try {
          replaced = replace(replacement, cleanInput, slicedResults, queryEngine);
          if (options.to || options.inPlace) {
            this.resultsFormat = 'pairs';
            out([name, replaced]);
          } else {
            out(replaced);
          }
        } catch (e$) {
          e = e$;
          this.console.error(name + ": Error during replacement. " + e.message + ".");
        }
      } else if (options.count) {
        if (options.displayFilename) {
          if (options.json || data) {
            this.resultsFormat = 'pairs';
            this.out([name, count]);
          } else {
            this.out(formatCount(color, count, name));
          }
        } else {
          this.out(options.json || data
            ? count
            : formatCount(color, count));
        }
      } else if (options.filesWithoutMatch || options.filesWithMatches) {
        if (options.filesWithMatches && count || options.filesWithoutMatch && !count) {
          this.out(options.json || data
            ? name
            : formatName(color, name));
        }
      } else {
        if (options.json || data) {
          if (options.displayFilename) {
            this.resultsFormat = 'pairs';
            this.out([name, slicedResults]);
          } else {
            this.resultsFormat = 'lists';
            this.out(slicedResults);
          }
        } else {
          inputLines = lines(cleanInput);
          inputLinesLength = cleanInput.length;
          for (i$ = 0, len$ = slicedResults.length; i$ < len$; ++i$) {
            result = slicedResults[i$];
            this.out(formatResult(name, inputLines, inputLinesLength, textFormatFuncs, options, result));
          }
        }
      }
      if (debug) {
        this.console.timeEnd("search-total:" + name);
      }
    };
    return Search;
  }());
}).call(this);
