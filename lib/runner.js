// Generated by LiveScript 1.5.0
(function(){
  var version, ref$, searchTarget, getQueryEngine, getDisplayFilename, Runner, slice$ = [].slice;
  version = require('../package.json').version;
  ref$ = require('./utils'), searchTarget = ref$.searchTarget, getQueryEngine = ref$.getQueryEngine, getDisplayFilename = ref$.getDisplayFilename;
  Runner = (function(){
    Runner.displayName = 'Runner';
    var prototype = Runner.prototype, constructor = Runner;
    function Runner(arg$){
      var ref$, args, error, ref1$, callback, exit, data, stdin, fs, textFormat, input, console, callCallback;
      ref$ = arg$ != null
        ? arg$
        : {}, args = ref$.args, error = (ref1$ = ref$.error) != null
        ? ref1$
        : function(it){
          throw new Error(it);
        }, callback = (ref1$ = ref$.callback) != null
        ? ref1$
        : function(){}, exit = (ref1$ = ref$.exit) != null
        ? ref1$
        : function(){}, data = (ref1$ = ref$.data) != null ? ref1$ : false, stdin = ref$.stdin, fs = (ref1$ = ref$.fs) != null
        ? ref1$
        : require('fs'), textFormat = (ref1$ = ref$.textFormat) != null
        ? ref1$
        : require('cli-color'), input = ref$.input, console = (ref1$ = ref$.console) != null ? ref1$ : _console;
      this.args = args;
      this.error = error;
      this.callback = callback;
      this.exit = exit;
      this.data = data;
      this.stdin = stdin;
      this.fs = fs;
      this.textFormat = textFormat;
      this.input = input;
      this.console = console;
      this.validateArgs();
      this.parseArgs();
      this.startDebug();
      this.handleVersion();
      this.handleHelp();
      this.handleJsx();
      this.queryEngine = getQueryEngine(options);
      this.setParser();
      this.setContext();
      this.handleFile();
      this.handleRecursive();
      this.handleReplace();
      this.handleSelector();
      options.displayFilename = getDisplayFilename(this.options, this.targets);
      this.setOutputFormat();
      this.prepareSearch();
      callCallback = !options.quiet && !options.json && !options.to && !options.inPlace;
      this.parseSelector();
      this.endDebug();
      this.setTestExt();
      this.setTestExclude();
      this.doSearch();
    }
    doSearch(function(){
      var cwd;
      this.targetPaths = [];
      if (this.input) {
        this.search('(input)', this.input);
        this.resultsFormat = this.search.resultsFormat;
        return end(['-']);
      } else {
        cwd = process.cwd();
        async.eachSeries(this.targets, searchTarget(cwd, cwd), function(){
          return end(this.targetPaths);
        });
      }
    });
    prepareSearch(function(){
      return this.search = new Search;
    });
    parseSelector(function(){
      if (this.debug) {
        console.time('parse-selector');
      }
      return this.parsedSelector = this.queryEngine.parse(this.selector);
    });
    setTestExt(function(){
      var exts, this$ = this;
      exts = this.options.extensions;
      return this.testExt = exts.length === 0 || exts.length === 1 && exts[0] === '.'
        ? function(){
          return true;
        }
        : function(it){
          return it.match(RegExp('\\.(?:' + exts.join('|') + ')$'));
        };
    });
    setTestExclude(function(){
      var exclude;
      exclude = options.exclude;
      return this.testExclude = !exclude || exclude.length === 0
        ? function(){
          return true;
        }
        : function(file, basePath, upPath){
          var filePath;
          filePath = path.relative(basePath, path.join(upPath, file));
          return exclude.every(function(excludePattern){
            return !minimatch(filePath, excludePattern, options.minimatchOptions);
          });
        };
    });
    setOutputFormat(function(){
      var ref$;
      this.color = Obj.map(function(it){
        if (this.options.color) {
          return it;
        } else {
          return function(it){
            return it + "";
          };
        }
      }, {
        green: (ref$ = this.textFormat).green,
        cyan: ref$.cyan,
        magenta: ref$.magenta,
        red: ref$.red
      });
      this.bold = this.options.bold
        ? this.textFormat.bold
        : function(it){
          return it + "";
        };
      return this.textFormatFuncs = {
        color: color,
        bold: bold
      };
    });
    setParser(function(){
      var ref$, parser, parserOptions;
      ref$ = (function(){
        switch (options.parser[0]) {
        case 'acorn':
          return [acorn, options.parser[1]];
        default:
          return [require(options.parser[0]), options.parser[1]];
        }
      }()), parser = ref$[0], parserOptions = ref$[1];
      this.parser = parser;
      return this.parserOptions = parserOptions;
    });
    setContext(function(){
      var ref$, ref1$;
      (ref$ = this.options).context == null && (ref$.context = (ref$ = this.options.NUM) != null ? ref$ : 0);
      (ref$ = this.options).beforeContext == null && (ref$.beforeContext = this.options.context);
      return (ref1$ = (ref$ = this.options).afterContext) != null
        ? ref1$
        : ref$.afterContext = this.options.context;
    });
    handleRecursive(function(){
      if (!this.targets.length) {
        return this.targets = options.recursive
          ? ['.']
          : ['-'];
      }
    });
    handleSelector(function(){
      var helpString;
      if (this.selector == null) {
        error('Error: No selector specified.');
        helpString = getHelp();
        callback(helpString);
        exit(2, helpString);
      }
    });
    handleReplace(function(){
      var that, e;
      if (that = this.options.replace != null || this.options.replaceFunc) {
        return this.replacement = that;
      } else if (that = this.options.replaceFile) {
        try {
          return this.replacement = this.fs.readFileSync(that, 'utf8').replace(/([\s\S]*)\n$/, '$1');
        } catch (e$) {
          e = e$;
          this.error("Error: No such file '" + this.options.replaceFile + "'.");
          this.exit(2);
        }
      }
    });
    handleFile(function(){
      var that, e;
      if ((that = this.options.file) != null) {
        try {
          this.selector = this.fs.readFileSync(that, 'utf8');
        } catch (e$) {
          e = e$;
          this.error("Error: No such file '" + this.options.file + "'.");
          this.exit(2);
          return;
        }
        return this.targets = this.positional;
      } else {
        this.selector = this.positional[0];
        return this.targets = slice$.call(this.positional, 1);
      }
    });
    handleHelp(function(){
      var helpString;
      if (this.options.help) {
        helpString = this.getHelp();
        this.callback(helpString);
        this.exit(0, helpString);
      }
    });
    getHelp(function(){
      return help(generateHelp, generateHelpForOption, this.positional, {
        version: version
      });
    });
    parseArgs(function(){
      var options, positional, debug, e;
      try {
        options = parseOptions(this.args), positional = options._, debug = options.debug;
        this.options = options;
        this.positional = positional || [];
        return this.debug = debug;
      } catch (e$) {
        e = e$;
        this.error(e.message);
        this.exit(2);
      }
    });
    validateArgs(function(){
      if (this.args == null) {
        this.error('Error: Must specify arguments.');
        this.exit(2);
      }
    });
    handleJsx(function(){
      if (this.options.jsx) {
        this.options.extensions.push('jsx');
        if (this.options.parser[0] === 'acorn') {
          require('acorn-jsx');
          return this.options.parser[1].plugins = {
            jsx: true
          };
        }
      }
    });
    handleVersion(function(){
      var versionString;
      if (this.options.version) {
        versionString = "grasp v" + version;
        this.callback(versionString);
        this.exit(0, versionString);
      }
    });
    startDebug(function(){
      if (this.debug == null) {
        return;
      }
      console.time('everything');
      console.log('options:');
      return console.log(options);
    });
    endDebug(function(){
      if (this.debug == null) {
        return;
      }
      console.timeEnd('parse-selector');
      console.log('parsed-selector:');
      return console.log(JSON.stringify(parsedSelector, null, 2));
    });
    return Runner;
  }());
}).call(this);
